This process is not quick, but it is reproducible.

1. Open the Earthbound game map in Photoshop
2. Create and name layers for each room and map region as follows:
	a. Edit > Preferences > Guides, Grid & Slices > Gridline Every: 64 Pixels, Subdivisions: 1
	b. View > Show > Grid
	c. Use Rectangular Marquee Tool, especially "Add to selection" and "Subtract from selection" 
	d. Arrange layers as specified:
	
		Region/
			Building/
				Room_[subroom 1]_..._[subroom n]
			Region
		
		or
		
		Region/
			Dungeon/
				[Main Room, Boss Room, Special Event Room, etc.]
				Room #
				Hallway #
		
		This organizes the rooms and regions of the game into a tree, or room hierarchy. The examples below describe this structure as well as the several naming conventions used to describe this arrangement in a manner that balances between organization and readability:
		
		Example 1: Most buildings have low room depth and can be named with the branch of the room hierarchy:
		
		Example 2: Each building in a region gets its own folder:
		
		Example 3: Dungeons have room hierarchies that are very deep, making for impractical names. As a compromise, dungeon areas are organized into "Rooms" and "Hallways", each numbered roughly by increasing travel distance from the dungeon entrance:
			Grapefruit Falls/
				Belch's Base/
					Main
					Boss Room
					Room 1
					Room 2
					Room 3

NOTE: I believe the set of layers in the Photoshop file is complete, but please submit an issue request if there are omissions. The chosen naming convention is, of course, open to discussion and can almost certainly be improved.

3. Export by layer using antipalindrome's Photoshop-Export-Layers-to-Files-Fast (https://github.com/antipalindrome/Photoshop-Export-Layers-to-Files-Fast) script.
	Settings: Pick the image settings you prefer, but use directories as folders and DO NOT crop to content.
4. [Hacky] Use Bulk Rename Utility to put all the image files into a single directory, renaming them such that the directory structure is prefixed to the filename.
5. Run "process-images.py" pointed at the directory containing all the image files. This script uses Wand to
	a. For each image
		Crop to content
		Store image filename, dimensions, and offset from the map origin
		Save using the above dimensions as "x0_y0_x1_y1_filename.png"
	b. Export stored list of dimensions to CSV
6. Open the stored list of dimensions and append it to GameData.npcs in main.py
	a. Collision detection against the list of dimensions using GameData.npcs.x_pixel_abs and y_pixel_abs
7. Export all GameData.npcs data to a CSV (note that some looping dialog trees can be quite large and set RECURSION_LIMIT accordingly)

The output is a list of all NPCs in the game, labeled according to sprite_groups.csv, and associated with one or more named regions. I say "one or more" because the overworld regions are saved in bounding boxes; thus, the coordinates (896, 2176) is simultaneously in the "Onett_Onett" and "Winters_Winters" bounding boxes and would match with both in collision detection. I'm sure this could be solved by manually setting priorities between regions in some kind of configuration file. But, I'm lazy, and identifying a named region from a set of pixels (say, read from game memory via LUA script) would be just for fun or YouTube purposes.

I'll add it to the to-do list because then again, perhaps this could also be used more constructively, say to output some simple information about which NPCs are in the region and the number of times they've been talked to. Certainly the eventual goal, and the highest standard of validation this run can have, is a script that validates, by means of a run recording, that all accessible dialog has been read.

Mainly this is an effort to ensure I have adequate material to route and visualize without needing to stop and refactor as I go. This is the amount and kind of data I believe will be necessary to accurately route the run, based on my sense after completing about 15% of the total run manually. Although the process described here is not fast, it should only need to be performed if there are updates to the underlying layer-based structure (e.g. reorganized, renamed, or re-sliced rooms) and mainly consists of idle operations that could perhaps be entirely automated with a batch script pointed at a Photoshop file and CoilSnake decompilation folder.